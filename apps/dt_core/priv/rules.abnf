if-rule = "IF" condition "THEN" SPS consequent [consparam] !!!
	_rule =  rule
	_string_values = string_values

	[_, condition, _, _, cons, conspar] = values
	condition = :lists.flatten condition
	cons = :lists.flatten cons
	conspar = :lists.flatten conspar

	expression = "if" <> to_string(condition) <> "do :" <> to_string(cons) <> " end"
	|> to_char_list

	{:ok, state, 
		%{code: expression,
		  param: conspar
		 }
	}
!!!

operator = ">" / "<" / "==" / "!=" !!!
	_rule =  rule
	_string_values = string_values

	{:ok, state, :lists.flatten(values)}	
!!!

condition = *( ( wrapcond / simplecond ) [ ("AND" / "OR") condition ] )

wrapcond = SPS "(" simplecond [ ("AND" / "OR") simplecond ] ")" SPS

simplecond = SPS lcondition SPS operator SPS rcondition SPS

lcondition = *( 1*ALPHA "." ) 1*ALPHA !!!
	_rule =  rule
	_string_values = string_values

	{:ok, state, :lists.flatten(values)}	
!!!

rcondition = string / 1*DIGIT / atom !!!
	_rule =  rule
	_string_values = string_values

	{:ok, state, :lists.flatten(values)}	
!!!

consequent = 1*ALPHA !!!
	_rule =  rule
	_string_values = string_values

	{:ok, state, :lists.flatten(values)}	
!!!

consparam = "(" *( 1*ALPHA / 1*(1*DIGIT / (1*DIGIT "." 1*DIGIT)) ) ")" !!!
	_rule =  rule
	_string_values = string_values

	[_, val, _] = values
	val = :lists.flatten val
	|> to_char_list

	{:ok, state, val}	
!!!

string = DQUOTE *( ALPHA / SP / DIGIT ) DQUOTE

atom = *( ALPHA / "_" / "-" / "@" / DIGIT ) !!!
	_rule =  rule
	_string_values = string_values

	value = :lists.flatten(values)
	|> to_string
	value = ":" <> value
	|> String.to_char_list
	{:ok, state, value}	
!!!

DQUOTE = %x22

SPS = *SP !!!
	_rule =  rule
	_string_values = string_values

	{:ok, state, :lists.flatten(values)}	
!!!

SP = %x20 

ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z

DIGIT = %x30-39

